import sys
sys.path.append('../astrodynamics')
import mars_standard_atmosphere as MSA
from reentry_footprint import flight, time, dt, mean_radius, mars, rho_0
import disturbances as dist
import actuator_properties as act

import numpy as np
from matplotlib import pyplot as plt

#=====================================================================================================================================================================================================================
#Node properties
#=====================================================================================================================================================================================================================
mu=0.042828*10**6*(10**3)**3    #[m^3/s^2] gravitational parameter
R=3389.5*10**3                  #[m] volumetric mean radius
h_node=500*10**3                #[m]

period = np.sqrt((R+h_node) ** 3 / mu)
omega = period / (2 * np.pi)

#=====================================================================================================================================================================================================================
#Vbar approach
#=====================================================================================================================================================================================================================
#Proximity operations A:
x0_A = 1000         #m
x1_A = 250          #m
t_A  = 5 * period   #s

#Proximity operations B:
x0_B = x1_A         #m
x1_B = 30           #m
t_B  = 70 * 60      #s
#Docking:
x0_d = x1_B         #m
x1_d = 3            #m
t_d  = 5 * 60       #m

y0 = z0 = 0
#=====================================================================================================================================================================================================================
#Vbar approach
#=====================================================================================================================================================================================================================
#Proximity operations A:
x0_A = 1000         #m
x1_A = 250          #m
t_A  = 5 * period   #s
Vx_A   = (x0_A - x1_A) / t_A #m/s

#Proximity operations B:
x0_B = x1_A         #m
x1_B = 30           #m
t_B  = 70 * 60      #s
Vx_B  = (x0_B - x1_B) / t_B #m/s
#Docking:
x0_d = x1_B         #m
x1_d = 3            #m
t_d  = 5 * 60       #m
Vx_d  = (x0_d - x1_d) / t_d #m/s

y0 = z0 = 0
#=====================================================================================================================================================================================================================
#Rbar approach
#=====================================================================================================================================================================================================================
#Proximity operations A:
z0_A = 1000         #m
z1_A = 250          #m
t_A  = 5 * period   #s

#Proximity operations B:
z0_B = x1_A         #m
z1_B = 30           #m
t_B  = 70 * 60      #s
#Docking:
z0_d = x1_B         #m
z1_d = 3            #m
t_d  = 5 * 60       #m

x0 = y0 = 0

#=====================================================================================================================================================================================================================
#Navigation measurement errors
#=====================================================================================================================================================================================================================
error_xm = 1
error_ym = 1
error_zm = 1

error_xdot = 1
error_ydot = 1
error_zdot = 1

delta_x = error_xm + 6 * error_zm * (omega * t - sin(omega * t)) +  error_xdot * (4 / omega * sin(omega * t) - 3 * t) + 2 / omega * error_zdot * (1 - cos(omega * t))
delta_y = error_ym * cos(omega * t) + 1 / omega * error_ydot * sin (omega * t)
delta_z = error_zm * (4 - 3 * cos(omega * t)) + 2 / omega * error_xdot * (cos(omega * t) -1) + 1 / omega * error_zdot * sin(omega * t)


#=====================================================================================================================================================================================================================
# Hill equations of motion
#=====================================================================================================================================================================================================================

def thrust_x(x,delta_x,delta_z,omega):
    x += delta_x
    z += delta_z
    xdot = np.gradient(x,t)
    xdotdot = np.gradient(xdot,t)
    zdot = np.gradient(z,t)
    zdotdot = np.gradient(zdot,t)
    gamma_x = (xdotdot - 2 * omega * zdot)
    return Fx

def thrust_y(delta_y,omega):
    y += delta_y
    ydot = np.gradient(y,t)
    ydotdot = np.gradient(ydot,t)
    gamma_y = (ydotdot + omega ** 2 * y)
    return Fy

def thrust_z(z,delta_x,delta_z,omega):
    x += delta_x
    z += detla_z
    xdot = np.gradient(x,t)
    zdot = np.gradient(z,t)
    zdotdot = np.gradient(zdot,t)
    gamma_z = (zdotdot * 2 * omega * xdot - 3 * omega ** 2 * z)
    return Fz

#=====================================================================================================================================================================================================================
# Simulation
#=====================================================================================================================================================================================================================

dt = 0.01
t = 0
x = x0_A + detla_x
y = y0 + delta_y
z = z0 + delta_z

while x < x1_A:
    x += Vx*dt + delta_x
    y += delta_y
    z += delta_z
    fx = thrust_x(x,delta_x,delta_z)
    fy = thrust_y(y,delta_y,)
